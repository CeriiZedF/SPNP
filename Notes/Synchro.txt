														Синхронізація 
-------------------
Для яких задача потрібна асинхронність:
- звільнення інтерфейсу користувача 
- можливість виконання інших задач доки виконується тривала задача
- нечутливість алгоритму до порядку виконання дій

Наприклад, треба порахувати річну інфляцію, тоді як відомі показники за кожен місяць. НБУ публікує 
відкриті ддані (місячна інфляція), запит даних за окремий місяць - звернення до мережі, що є тривалим процесом.
Якщо порядок урахування місяців не має значення, то ці процеси можна виконувати асинхронно.

Обгрунтування: (100 + 10%) + 20% =?= (100 + 20%) + 10%
+10% -- x1.1, +20% -- x1.2
100x1.1x1.2 == 100x.2x1.1 - в залежносі від порядку
=> можна вирішувати асинхронно

Спроба утворювати транзакціями усе тіло методу по факту "знімає" асинхронність і всі методи чекаюсть своєї черги і спрацьовуватимуть
по одному. Якщ код не дозволяє виділити транзакцію менше, ніж усе тіло, то такий код слід рефакторити (переписувати), переміщуючи роботу зі 
СПІЛЬНИМ РЕСУРСОМ в якомога менші блоки

Примітиви синхронізації
Є у системі "сигнальні" об'єкти - які сигналізують системі про зміну свого стану. 
Окремі з них використовуються для задач синхронізації
-----X       0----X----
-----X       |    0-----
-----0-------X----

Критична секція (пам'яті) - один з найпростіших об'єктів синхронізації і
така секція є у кожного reference-type об'їкта .NET
lock переводить критичну секцію об'єкта до "закритого" стану.
Це не дає іншим потокам увійти до блоку lock (з тим же об'єктом синхронізації)
sumLocker 00000XXXXXXX0XXXXXXXX0000000000
---lock(sumLocker) {--------}--------
---lock(sumLocker) |		 {-------}

Sting str = "Hello"
...
lock(str)
{
str += ' ';			Строки - незмінні і він не роблокується ніколи, str ++ ' '  --> str = new String(str + ' ')
}

!!!Украй рекомендується до lock(x) ставити константні об'єкти!!!

lock(StringBuilder)  --припустИмо але не рекомендовано!
{
	StringBuilder.Append("val");
}

